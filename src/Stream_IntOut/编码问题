编码起源发展：
1、ASCII：美国标准信息交换码表
    每个字符用一个字节的低7位表示。第8位0
2、ISO8859-1:拉丁码表
    因为ASCII码无法表示欧洲的一些文字符号，进而有了该码表
    每个字符都是用一个字节8位表示，进而导致可以用来反编码解决译码错误问题。——Tomcat
3、GB2312:中国起初的编码表，因为容纳的汉字（2~3千）过少，每个汉字两个字节。
            改进了
4、GBK：改进了GB2321码表。

又因为每个国家都有自己的码表带来了不方便，进而产生了统一标准码表
5、Unicode码表：国际标准码表，包含多国汉字。
        每个字符都用2个字节表示。进而导致一些字符（本可以用一个字节）却用了2个字节带来了浪费空间。
6、UTF-8：因为Unicode浪费空间。改进了。
    能用一个字节就用一个字节存，最多不超过3个字节。

    此外还有UTF-16....
    其如何标识一个字节？2个字节？3个字节？
    范围'\u0001'至'\u007F'中的字符由单个字节表示。
    空字符'\u0000'和范围'\u0080'到'\u07FF'中的字符由一对字节表示。
    范围'\u0800'至'\uFFFF'中的字符由三个字节表示。

Modified UTF-8
DataInput和DataOutput接口的实现表示Unicode字符串，其格式略微修改为UTF-8。 （有关标准UTF-8格式的信息，请参见3.9 Unicode标准的 Unicode编码格式 ，版本4.0 ）

范围'\u0001'至'\u007F'中的字符由单个字节表示。
空字符'\u0000'和范围'\u0080'到'\u07FF'中的字符由一对字节表示。
范围'\u0800'至'\uFFFF'中的字符由三个字节表示。
Encoding of UTF-8 values Value Byte Bit Values 7 6 5 4 3 2 1 0 \u0001 to \u007F 1 0 bits 6-0 \u0000,
\u0080 to \u07FF 1 1 1 0 bits 10-6 2 1 0 bits 5-0 \u0800 to \uFFFF 1 1 1 1 0 bits 15-12 2 1 0 bits 11-6 3 1 0 bits 5-0
此格式与标准UTF-8格式之间的差异如下：

空字节'\u0000'以2字节格式而不是1字节编码，因此编码的字符串永远不会嵌入空值。
仅使用1字节，2字节和3字节格式。
Supplementary characters以代理对的形式表示。


相关的问题细节：
1、编错码，解不出来！
瞎几把编码，市面上没有与之对应的编码表，就无法解码。

2、编对码，解错码，有可能还能重新解!
比如“你好”，使用GBK编码，如果使用ISO8859-1来解码，因为是一个字节的编码表 ，所以得到了未知字符，这些字符同样是
一一对应编码值的。所以我们反编码得其ISO8859-1的编码值，然后再根据该编码值以GBK解，就能得到“你好”

假设我们使用了UTF-8来解码，解错了。那么因为UTF-8的编码字节不唯一，导致其未知区的编码值都是一样的。
进而导致了即使使用反编码，我们得到的是是相同的一组编码值，所以此时用GBK来编码该编码值得到的不是源数据。

3、联通问题
字符“联通”其二进制


编码方法：
byte[] getBytes();//默认以系统环境的编码集编码。
byte[] getBytes(String charset);//使用指定的编码集来编码。


